# ⌨️ SkillHub

### Вопрос 1
Представим, что у тебя проект на SwiftUI + Combine. Как ты отделишь бизнес-логику от UI, и где будет храниться логика фильтрации данных?

> Ответ:
В таком проекте я бы использовал архитектурный паттерн MVVM (Model-View-ViewModel). В этом случае UI в SwiftUI будет зависеть от ViewModel, а вся бизнес-логика будет храниться в нем. ViewModel будет обрабатывать данные, взаимодействовать с моделью (например, с сетевыми запросами, базой данных и фильтрацией данных) и обновлять UI через Combine.

> Фильтрация данных будет происходить внутри ViewModel. Мы можем использовать Combine для реактивного обновления UI при изменении данных. Например, если есть массив данных, то фильтрацию можно проводить через Publisher, который будет эмитировать обновления фильтрованного массива. Вся логика взаимодействия с данными будет спрятана в ViewModel, а UI будет только отображать результат.

### Вопрос 2
Ты получил баг-репорт: "экран зависает при переходе к экрану деталей после логина". Опиши, как ты бы начал отладку.

> Ответ:
В первую очередь, я бы воспроизвел проблему на локальной машине, чтобы понять, при каких условиях она возникает. Я бы также проверил логи на предмет ошибок, чтобы понять, что именно может вызывать зависание — это может быть сетевой запрос, тяжелая обработка данных или проблемы с UI.

> Затем, я бы проверил, не возникает ли каких-либо блокировок в основном потоке, таких как синхронные операции, которые могут замедлять или блокировать переход на новый экран. Если переход зависит от данных с сервера, возможно, это происходит из-за долгого ожидания ответа. Я бы также убедился, что все сетевые запросы выполняются асинхронно и не блокируют главный поток.

> Для диагностики можно использовать профилировщик в Xcode, например, Instruments, чтобы увидеть, есть ли какие-либо утечки памяти или длительные операции, которые могут блокировать интерфейс.

### Вопрос 3
Какие основные особенности и ограничения ты знаешь при работе с Call Directory Extension или Network Extension на iOS?

> Ответ:
Call Directory Extension используется для блокировки звонков или идентификации неизвестных номеров. Основные особенности:

> Требуется разрешение пользователя для работы.

> Не поддерживает все типы звонков, такие как VoIP.

> Для обновления данных блокировки или идентификации звонков, необходимо запрашивать у пользователя обновление данных через функцию CXCallDirectoryManager.

> Network Extension используется для работы с сетями, например, для VPN. Основные ограничения:

> Требует специальных разрешений от Apple для работы с такими функциями.

> Может потребовать использования особых API для настройки и управления сетевыми расширениями.

> Ограничения по доступу к определённым типам сетевого трафика в зависимости от конфигурации.

### Вопрос 4
Допустим, ты делаешь чат. Как бы ты реализовал обновление UI при приходе новых сообщений?

> Ответ:
Для реализации обновления UI при получении новых сообщений можно использовать Combine и ObservableObject в SwiftUI. Мы можем создать ViewModel, который будет подписан на поток сообщений и обновлять UI каждый раз, когда приходит новое сообщение.

Пример:

> Когда приходит новое сообщение, сервер уведомляет приложение через push-уведомление или WebSocket.

> Это уведомление обрабатывается в ViewModel, который обновляет свой список сообщений.

> Благодаря Combine UI автоматически обновляется, потому что мы используем @Published свойства для хранения сообщений.

> Можно также использовать различные методы для повышения производительности, например, ленивая загрузка сообщений или разбивка сообщений на страницы.
